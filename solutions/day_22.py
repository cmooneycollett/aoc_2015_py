from copy import deepcopy
from enum import Enum, auto, unique


@unique
class Spell(Enum):
    MAGIC_MISSILE = auto()
    DRAIN = auto()
    SHIELD = auto()
    POISON = auto()
    RECHARGE = auto()

    def get_mana_cost(self):
        """
        Gets the mana cost required to cast the spell.
        """
        match self:
            case Spell.MAGIC_MISSILE:
                return 53
            case Spell.DRAIN:
                return 73
            case Spell.SHIELD:
                return 113
            case Spell.POISON:
                return 173
            case Spell.RECHARGE:
                return 229

    def get_effect_turns(self):
        """
        Gets the number of turns that the effect generated by the spell lasts
        for.
        """
        match self:
            case Spell.MAGIC_MISSILE:
                return 0
            case Spell.DRAIN:
                return 0
            case Spell.SHIELD:
                return 6
            case Spell.POISON:
                return 6
            case Spell.RECHARGE:
                return 5

    @staticmethod
    def list():
        """
        Returns a list containing each unique member of the Spell enum-class.
        """
        return list(map(lambda c: c, Spell))


class Entity:
    def __init__(self, hp, damage, armour):
        self.hp = hp
        self.damage = damage
        self.armour = armour

    def deal_damage(self, damage):
        damage_to_deal = damage - self.armour
        if damage_to_deal < 1:
            damage_to_deal = 1
        self.hp -= damage_to_deal

    def heal(self, hp):
        self.hp += hp

    def is_dead(self):
        return self.hp <= 0


class Player(Entity):
    def __init__(self, hp, mana):
        self.hp = hp
        self.damage = 0  # Damage is dealt by player via spells
        self.active_effects = {}   # Track active effect and remaining turns
        self.mana = mana
        self.total_mana_spent = 0   # Track total mana expended by player
        self.armour = 0  # Player armour rating can be modified by spells

    def can_cast_with_mana(self, spell):
        return self.mana >= spell.get_mana_cost()

    def is_effect_active(self, spell):
        return spell in self.active_effects

    def cast_spell(self, spell, enemy):
        # Check if player has enough mana remaining
        if not self.can_cast_with_mana(spell) or self.is_effect_active(spell):
            return
        # Expend mana to cast spell
        self.total_mana_spent += spell.get_mana_cost()
        self.mana -= spell.get_mana_cost()
        match spell:
            case Spell.MAGIC_MISSILE:
                enemy.deal_damage(4)
            case Spell.DRAIN:
                enemy.deal_damage(2)
                self.heal(2)
            case Spell.SHIELD:
                self.active_effects[spell] = spell.get_effect_turns()
                self.armour += 7
            case Spell.POISON:
                self.active_effects[spell] = spell.get_effect_turns()
            case Spell.RECHARGE:
                self.active_effects[spell] = spell.get_effect_turns()

    def process_effects(self, enemy):
        effects_to_remove = []
        for effect in self.active_effects.keys():
            # Reduce effect turns remaining by 1
            self.active_effects[effect] -= 1
            match effect:
                case Spell.SHIELD:
                    if self.active_effects[effect] <= 0:
                        self.armour -= 7
                        effects_to_remove.append(effect)
                case Spell.POISON:
                    enemy.deal_damage(3)
                    if self.active_effects[effect] <= 0:
                        effects_to_remove.append(effect)
                case Spell.RECHARGE:
                    self.mana += 101
                    if self.active_effects[effect] <= 0:
                        effects_to_remove.append(effect)
        for effect in effects_to_remove:
            self.active_effects.pop(effect)


def main():
    input = process_input_file()
    p1_solution = solve_part1(input)
    print("P1 solution - {}".format(p1_solution))
    p2_solution = solve_part2(input)
    print("P2 solution - {}".format(p2_solution))


def process_input_file():
    with open("./inputs/day_22.txt") as file:
        enemy_stats = {}
        for line in file.readlines():
            line = line.strip()
            if len(line) == 0:
                continue
            sep = line.split(": ")
            enemy_stats[sep[0]] = int(sep[1])
        return Entity(enemy_stats["Hit Points"], enemy_stats["Damage"], 0)


def solve_part1(input):
    boss = deepcopy(input)
    player = Player(50, 500)
    least_mana_for_win = conduct_fight(player, boss)
    return least_mana_for_win


def solve_part2(input):
    ()


def conduct_fight(player, boss):
    """
    Conducts the fight between the player and boss, returning the least amount
    of mana the player needs to spend to still beat the boss.
    """
    min_mana = []
    conduct_fight_recursive(player, boss, min_mana)
    if len(min_mana) == 1:
        return min_mana[0]
    else:
        return -1


def conduct_fight_recursive(player, boss, min_mana):
    """
    Conduct one step in the fight between player and boss, making recursive
    function calls to proceed to the next step in a fight.
    """
    # Select player spell
    for spell in Spell.list():
        # Copy player and boss
        new_player = deepcopy(player)
        new_boss = deepcopy(boss)
        # Player turn
        # - Process player effects and check if boss is dead
        new_player.process_effects(new_boss)
        if new_boss.is_dead():  # Player wins
            if len(min_mana) == 0:
                min_mana.append(new_player.total_mana_spent)
            elif min_mana[0] > new_player.total_mana_spent:
                min_mana[0] = new_player.total_mana_spent
            return
        # - Cast spell - player loses if they do not have enough mana to cast a spell
        can_cast = new_player.can_cast_with_mana(spell)
        if not can_cast:    # Player loses
            return
        # If spell cannot be cast due to active effect, continue to next spell
        if new_player.is_effect_active(spell):
            continue
        new_player.cast_spell(spell, new_boss)
        # - Check if boss is dead
        if new_boss.is_dead():  # Player wins
            if len(min_mana) == 0:
                min_mana.append(new_player.total_mana_spent)
            elif min_mana[0] > new_player.total_mana_spent:
                min_mana[0] = new_player.total_mana_spent
            return

        # Boss turn
        # - Process player effects and check if boss is dead
        new_player.process_effects(new_boss)
        if new_boss.is_dead():  # Player wins
            if len(min_mana) == 0:
                min_mana.append(new_player.total_mana_spent)
            elif min_mana[0] > new_player.total_mana_spent:
                min_mana[0] = new_player.total_mana_spent
            return
        # - Boss deal damage to player
        new_player.deal_damage(new_boss.damage)
        # - Check if player is dead
        if new_player.is_dead():    # Player loses
            return
        # Player and boss still alive, so go to next turn
        conduct_fight_recursive(new_player, new_boss, min_mana)


if __name__ == "__main__":
    main()
